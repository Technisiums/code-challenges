import sys

import pandas as pd
import requests
from pydantic import BaseModel
from requests.auth import HTTPBasicAuth

API = "https://api-backend-olsgyubl4a-ew.a.run.app"
# API = "http://localhost:8000"


class Credentials(BaseModel):
    client_id: str
    client_secret: str


def get_jwt_token(credentials: Credentials) -> str:
    """
    calls /oauth2/v2.0/token endpoint to get jwt-token based on credentials
    :param credentials: contains client-id and client-secret
    :return: jwt_token
    """
    resp = requests.post(f"{API}/oauth2/v2.0/token",
                         auth=HTTPBasicAuth(credentials.client_id, credentials.client_secret))
    resp.raise_for_status()
    return resp.json()['access_token']


def verify_jwt_token(credentials: Credentials, jwt_token: str):
    """
    verifies a given jwt-token
    :param credentials: contains client-id and client-secret
    :param jwt_token: jwt-token generated by API
    :return: None (throws an exception in case if token is corrupted or doesn't belong the user making requests
    """
    resp = requests.get(f"{API}/users/me", headers={'Authorization': f'Bearer {jwt_token}'})
    resp.raise_for_status()
    if resp.json()['client_id'] != credentials.client_id:
        raise Exception("Client ID in JWT token should match with client_id")


def serialize_dataframe(data: pd.DataFrame) -> list:
    """
    reformat the dataframe to required format
    :param data: dataframe containing prices.csv file content
    :return: list of products grouped by product_id
    """
    products_data = []
    for product_id, product_group in data.groupby('product_id'):
        prices_data = []
        for _, row in product_group.iterrows():
            price_data = {
                'market': row['market'],
                'channel': row['channel'],
                'price': row['price'],
                'valid_from': row['valid_from'],
                'valid_until': row['valid_until'],
            }
            prices_data.append(price_data)

        product_data = {
            'product_id': product_id,
            'prices': prices_data,
        }
        products_data.append(product_data)
    return products_data


def verify_upload(jwt_token: str):
    """
    API call will give back the data about uploaded data under the session ID,
    - can be used to verify if the file has been created on the server side by upload endpoint.
    :param jwt_token: JWT token generated by API
    :return: gsc url and error
    """
    resp = requests.get(
        f"{API}/validate-product-prices",
        headers={'Authorization': f'Bearer {jwt_token}'}
    )
    resp.raise_for_status()
    return resp.json()['gcs_upload']


def upload_prices(credentials: Credentials, data: pd.DataFrame):
    """
    - creates a JWT token by credentials
    - verifies the JWT token
    - serialize dataframe to required format
    - makes chunks if the length of data is > 1000
    - uploads each chunk with the same session ID/token
    - verifies the upload and logs/prints the gsc metadata
    :param credentials: contains client_id and client_secret
    :param data: data to be uploaded
    :return: None
    """

    jwt_token = get_jwt_token(credentials)
    verify_jwt_token(credentials, jwt_token)
    products_data = serialize_dataframe(data)
    chunk_size = 1000
    chunks = [products_data[i:i + chunk_size] for i in range(0, len(products_data), chunk_size)]
    for chunk in chunks:
        resp = requests.post(
            f"{API}/product-prices",
            json={'products': chunk},
            headers={'Authorization': f'Bearer {jwt_token}'}
        )
        resp.raise_for_status()
    gcs = verify_upload(jwt_token)
    print('GCS URL:', gcs['url'])
    print('GCS error:', gcs['error'])


if __name__ == "__main__":
    with open(sys.argv[1]) as f:
        creds = Credentials.model_validate_json(f.read())
    upload_prices(creds, pd.read_csv(sys.argv[2]))
